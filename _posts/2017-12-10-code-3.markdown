---
layout: post
title:  "SpringSecurity(三)"
description: SpringSecurity配置扩展
categories: code
author: mandy-one
---
# 配置扩展
本节我们将在最小化springsecurity配置的基础上进行扩展，学习springsecurity的扩展属性配置
## 表单和基础登录选项
 **1. 登录页面**<br>
任何访问登录页面的请求都是被允许的，主要是针对匿名用户。
```
<intercept-url pattern="/login.jsp*" access="IS_AUTHENTICATED_ANONYMOUSLY"/>
```
此外，上节我们提到http中还可以配置一个模式，通过将“Security”属性设置为“none”，从而完全绕过Spring Security的过滤器，通常以此配置自定义的登录页面。
```
<http pattern="/loginPage" security="none"></http>
```
显然，第二种方式更推荐使用，对于登录页面，绕过了通过Spring Security过滤器的步骤。<br>
**2. 使用基础验证(Http Basic authentication )**<br>
```
<http use-expressions="false">
<intercept-url pattern="/**" access="ROLE_USER" />
<http-basic />
</http>
```
基础验证将会生效，当用户尝试去访问一个保护的资源时将会提示需要登录。在这个配置中，表单登录仍然可用，如果你想用的话，例如通过一个登录表单内嵌另外一个web网页。<br>
**3. 登录页面及登陆后的默认目标地址**<br>
如果尝试访问一个受保护的资源，没有提示登陆页面URL，则采用系统默认登录页面，若自己指定URL可自己编辑页面。<br>
认证成功后跳转页面有如下四种情况（代码为前三种示例）:<br>
* 可通过authentication-success-forward-url指定认证成功跳转页面；
* 通过authentication-success-handler-ref 制定认证成功处理类；
* 若未作指定，可通过always-use-default-target设置为true则启用default-target-url，用户将会被带到这个URL上，默认是"/"，也可以自己进行配置；
* 若以上三种均未作指定，则认证成功后默认跳转到认证前所请求URL。

```
<form-login login-page='/login' authentication-success-forward-url="/success" />
<form-login login-page='/login' authentication-success-handler-ref="authenticationSuccessHandler" />
<form-login login-page='/login' default-target-url='/success' always-use-default-target='true' />
```
**4. 注销处理**<br>
logout 元素用于添加对注销功能支持，注销后可以访问一个特定的URL。默认的注销URL是 /logout。但是你可以使用 logout-url属性设置为其他的地址。(还可查看命名空间说明看其他属性项，如下注销则session失效属性)
```
<logout logout-url="/logout" logout-success-url="/login" invalidate-session="true"/>
```
## 使用其他的Authentication Providers
不要因为名字迷惑，其实这个配置重要的就是改变用户信息源。在实践中，你将会需要一个更加可扩展的用户信息源而不是添加在application context文件中的一些静态用户时，可以发现在<authentication-provider>下的配置项中除了user-service还有jdbc-user-service和ldap-user-service。第一种比较简单，我们在前一节做了实现且知道其有固定格式，这种格式由UserDetailsService所确定，由名字可知其为用户信息的服务层接口。其他两种分别对应用户的信息存储在数据库或者ldap服务器。我们在此处做数据库实现。使用jdbc-user-service配置如下：
```
<authentication-manager alias="authenticationManager">
     <authentication-provider>
        <!-- 基于 Jdbc 的 UserDetailsService 实现，JdbcDaoImpl -->
        <jdbc-user-service data-source-ref="dataSource"/>
     </authentication-provider>
  </authentication-manager>
```
再配置好相应的数据源即可。
使用 jdbc-user-service 元素时在底层 Spring Security 默认使用的UserDetailsService 是 JdbcDaoImpl，它对应默认的数据库表结构，创建脚本如下：
```
create table users(
      username varchar_ignorecase(50) not null primary key,
      password varchar_ignorecase(50) not null,
      enabled boolean not null);

create table authorities (
      username varchar_ignorecase(50) not null,
      authority varchar_ignorecase(50) not null,
      constraint fk_authorities_users foreign key(username) references users(username));
      create unique index ix_auth_username on authorities (username,authority);

create table groups (
  id bigint generated by default as identity(start with 0) primary key,
  group_name varchar_ignorecase(50) notnull);

create table group_authorities (
  group_id bigint notnull,
  authority varchar(50) notnull,
  constraint fk_group_authorities_group foreign key(group_id) references groups(id));

create table group_members (
  id bigint generated by default as identity(start with 0) primary key,
  username varchar(50) notnull,
  group_id bigint notnull,
  constraint fk_group_members_group foreign key(group_id) references groups(id));
```
以上修改用户信息源的过程可以看到，修改用户信息源也关系到UserDetailsService这个接口的实现，因此，当我们修改用户信息源不再匹配内部默认的UserDetailsService实现时，我们就有必要对UserDetailsService进行相应的实现。在上面改变用户信息源的配置实际上基本等价于如下配置，JdbcDaoImpl即是一种对UserDetailsService的实现。

```
   <authentication-manager alias="authenticationManager">
      <authentication-provider
         user-service-ref="userDetailsService" />
   </authentication-manager>

   <bean id="userDetailsService"
      class="org.springframework.security.core.userdetails.jdbc.JdbcDaoImpl">
      <property name="dataSource" ref="dataSource" />
   </bean>
  ```
再配置好相应的数据源即可。但是有一点需要注意的是使用 jdbc-user-service 定义的 UserDetailsService 是不支持用户组权限的，如果需要支持用户组权限的话需要我们采用第二种方式使用 JdbcDaoImpl,同时添加参数配置：
```
<property name="enableGroups" value="true"/>
```
至此，我们已经完成了一个重要接口，用来处理认证（Authentication）请求的接口AuthenticationManager的自定义实现的重要一部分。本接口为认证管理器，是实现用户认证的入口，需要改变认证的方式，我们可以实现自己的 AuthenticationProvider（在没有特殊需求下通常不需要改变）；如果需要改变认证的用户信息来源，我们可以实现 UserDetailsService（上述即为一种实现，此外，还可以自定义UserDetailsService就更具有灵活性）。<br>
**密码保护**<br>
通常我们保存的密码都不会像之前介绍的那样，保存的明文，而是加密之后的结果。为此，我们的 AuthenticationProvider 在做认证时也需要将传递的明文密码使用对应的算法加密后再与保存好的密码做比较。Spring Security 对这方面也有支持。通过在 authentication-provider 下定义一个 password-encoder 我们可以定义当前 AuthenticationProvider 需要在进行认证时需要使用的 password-encoder。password-encoder 是一个 PasswordEncoder 的实例，我们可以直接使用它，如：
```
<authentication-manager>
      <authentication-provider user-service-ref="userDetailsService">
         <password-encoder hash="md5"/>
      </authentication-provider>
   </authentication-manager>
```
也可以配置密码编码器:
```
<password-encoder ref="bcryptEncoder"/>
```
配置方法如上所属，其中涉及的具体方法及多种编码器引入如有需要可详细探究。
## Remember-Me 功能
Remember-Me 是指网站能够在 Session 之间记住登录用户的身份，具体来说就是我成功认证一次之后在一定的时间内我可以不用再输入用户名和密码进行登录了，系统会自动给我登录。这通常是通过服务端发送一个 cookie 给客户端浏览器，下次浏览器再访问服务端时服务端能够自动检测客户端的 cookie，根据 cookie 值触发自动登录操作。Spring Security针对 Remember-Me 功能有两种实现。一种是简单的使用加密来保证基于 cookie 的 token 的安全，另一种是通过数据库或其它持久化存储机制来保存生成的 token。第一种应用比较简单，第二种安全性更高，具体原理不做重点说明。<br>
需要注意的是两种实现都需要一个 UserDetailsService。如果你使用的 AuthenticationProvider 不使用 UserDetailsService，那么记住我将会不起作用，除非在你的 ApplicationContext 中拥有一个 UserDetailsService 类型的 bean。<br>
**基于简单加密 token 的方法（存在隐患）**<br>
当用户选择了记住我成功登录后，Spring Security 将会生成一个 cookie 发送给客户端浏览器。
```
base64(username+":"+expirationTime+":"+md5Hex(username+":"+expirationTime+":"+password+":"+key))
```
只需要在 http 元素下定义一个 remember-me 元素,同时指定其 key 属性即可。key 属性是用来标记存放 token 的 cookie 的。
```
<remember-me key="elim"/>
```
这里有两个需要注意的地方。一，如果你的登录页面是自定义的，那么需要在登录页面上新增一个名为 “_spring_security_remember_me” 的 checkbox;二，上述功能需要一个 UserDetailsService，如果在你的 ApplicationContext 中已经拥有一个了，那么 Spring Security 将自动获取；如果没有，需要定义一个；如果拥有在 ApplicationContext 中拥有多个 UserDetailsService 定义，那么需要通过 remember-me 元素的 user-service-ref 属性指定将要使用的那个。<br>
**基于持久化 token 的方法（推荐）**<br>
使用持久化 token 方法时需要我们的数据库中拥有如下表及其表结构。
```
create table persistent_logins (username varchar(64) not null,
                                    series varchar(64) primary key,
                                    token varchar(64) not null,
                                    last_used timestamp not null)
```
还是通过 remember-me 元素来使用，只是这个时候我们需要其 data-source-ref 属性指定对应的数据源，同时别忘了它也同样需要 ApplicationContext 中拥有 UserDetailsService，如果拥有多个，请使用 user-service-ref 属性指定 remember-me 使用的是哪一个。
```
<remember-me data-source-ref="dataSource"/>
```
## 添加HTTP/HTTPS通道安全
如果你的应用同时支持HTTP和HTTPS，并且你需要特定的URL只能通过HTTPS进行访问， <intercept-url>上的属性 requires-channel对此提供了直接的支持。
```
<http>
  <intercept-url pattern="/secure/**" access="ROLE_USER" requires-channel="https"/>
  <intercept-url pattern="/**" access="ROLE_USER" requires-channel="any"/>
  ...
</http>
```
进行了这样的配置后，如果一个用户尝试通过HTTP访问匹配"/secure/**"模式的任何资源，首先将会被重定向到一个HTTPS URL。可用的选项有"http"、"https"和"any"，使用any表示HTTP和HTTPS都可以使用。<br>
如果你的应用使用非标准的HTTP、HTTPS端口，你可以按照如下方式指定一个端口映射列表：
```
<http>
...
<port-mappings>
        <port-mapping http="9080" https="9443"/>
</port-mappings>
</http>
```
注意为了可以真正的受到保护，一个应用根本不应该使用HTTP或者在HTTP与HTTPS之间进行切换。应该通过HTTPS，使用安全的链接来避免可能的"中间人"攻击。
## Session管理
**1. 检测超时**<br>
你可以配置spring security来支持检测一个过期的session ID并将用户重定向到一个合适的URL。这通过session管理元素实现。
```
<session-management invalid-session-url="/invalidSession.htm" />
```
注意，如果你使用这种机制来检测session超时，如果用户注销后，没有关闭浏览器又重新登录了，可能会错误的报告一个异常。这是因为当你让session失效时没有清空session的cookie。你可以在注销的时候显式的指定删除名为JSESSIONID的cookie。例如你可以在注销处理器中使用以下的语法：
```
<logout delete-cookies="JSESSIONID" />
```
不幸的是并不能保证在每一个servlet容器中这都功能起到作用，所以你需要在自己的环境中进行测试。<br>
提示：如果你在一个代理之后运行自己的应用，你同样可以通过配置代理服务器来删除session cookie。例如使用 apache HTTPD的mod_headers，以下的指令将会删除 JSESSIONID cookie，原理是在一个注销请求的响应中设置cookie过期。(假设应用的部署路径是 /tutorial)
```
<LocationMatch "/tutorial/logout">Header always set Set-Cookie
     "JSESSIONID=;Path=/tutorial;Expires=Thu, 01 Jan 1970 00:00:00 GMT"
</LocationMatch>
```
**2. 当前session控制**<br>
如果你想限制只有一个用户可以登录你的应用，Spring Security通过以下的简单附加配置对此提供支持。首先你需要在你的web.xml文件中添加以下的监听器来保证session生命周期事件发生时Spring Security被更新。
```
<listener>
    <listener-class>
          org.springframework.security.web.session.HttpSessionEventPublisher
   </listener-class>
</listener>
```
接着在你的application context(即securityConfig.xml)中添加以下内容
```
<session-management>
       <concurrency-control max-sessions="1" />
</session-management>
```
这将会阻止一个用户多次进行登录--第二次登录将会导致第一个session失效。通常情况下你可能会阻止第二次登录，在这种场景下你可以使用：
```
<session-management>
        <concurrency-control max-sessions="1" error-if-maximum-exceeded="true" />
</session-management>
```
二次登录就会被拒绝，"拒绝"的意思是用户将会被带到 authentication-failure-url指定的url（如果使用了基于表单登录的话）。如果二次验证是通过另外的非交互的机制发生的，例如" remember-me"，一个“ unauthorized”401错误将会被发送给客户端。如果你想用一个错误页面来替代。你可以在 session-management元素中添加属性 session-authentication-error-url。<br>
如果你为表单登录使用了一个自定义的验证过滤器，那么你必须显式的配置当前session控制的支持。

## 添加你自己的Filter
Spring Security为了提供其服务在内部维护了一个过滤器链，当使用命名空间的时候，filter的执行顺序是强制的。当application context被创建，命名空间处理的代码将会对filter进行排序，并且每一个自带的Spring Security过滤器在命名空间中都有一个别名和已知的位置。<br>
Filter的顺序，定义在类org.springframework.security.config.annotation.web.builders.FilterComparator中。可以在其中添加自己的过滤器，使用custom-filter元素和这些名字中的其中一个来指定你的过滤器应该出现的位置：
```
<custom-filter position="FORM_LOGIN_FILTER" ref="myFilter" />
```
如果你希望你的过滤器在过滤器链中某个filter之前或者之后插入，你同样可以使用 after 或者 before 属性 。" FIRST"和"LAST"可以用在position属性上，来表明你希望你的过滤器出现在spring-security整个过滤器栈之前或者之后。提示：如果你插入一个自定义过滤器，其占用了由命名空间创建的某一个标准过滤器的位置，那么你不能引入命名空间版本。移除任何元素都将会创建你希望替换的功能的过滤器。<br>
注意不能通过http元素自身替换其创建的过滤器：
SecurityContextPersistenceFilter、 ExceptionTranslationFilter 、 FilterSecurityInterceptor。一些其他的过滤器默认会添加，但是你也可以禁用它们。 AnonymousAuthenticationFilter 默认会被添加，并且除非你希望会话固定保护被禁用，否则 SessionManagementFilter 也会被添加到过滤器链中。<br>
如果你替换了一个需要验证入口(authentication entry point)的命名空间过滤器，你同样需要添加一个自定义的入口bean。验证入口指的是：当一个未通过验证的用户尝试访问一个受保护的资源触发的验证过程。
## 默认的AccessDecisionManager
当你使用一个命名空间配置，将会为你注册一个默认的 AccessDecisionManager 实例，其基于 intercept-url和 protect-pointcut的声明(或者是注解)，来对web URL和方法调用做出一些访问判断。<br>
默认的策略是使用带有 RoleVoter 和 AuthenticatedVoter的 AffirmativeBased 、AccessDecisionManager 。<br>
**自定义AccessDecisionManager**<br>
如果你需要使用一个更加复杂的访问控制策略，那么你要知道对于方法安全和web安全设置一个替代者都非常简单。对于方法安全，你通过设置 global-method-securit元素的 access-decision-manager-ref属性 来指向一个在application context中定义的合适的 AccessDecisionManager bean的id。
```
<global-method-security access-decision-manager-ref="myAccessDecisionManagerBean">
...
</global-method-security>
```
web安全的语法是相同的，但是是放在http元素上
```
<http access-decision-manager-ref="myAccessDecisionManagerBean">
...
</http>
```
## 验证管理器和命名空间
Spring Secuirty中提供验证服务的主要接口是 AuthenticationManager,其是Spring Security ProviderManager类的一个实例，通过命名空间的元素 authentication-manager进行bean的注册。如果你在命名空间中使用了其他的命名空间或者访问安全，你就不能使用一个自定义的 AuthenticationManager ，因为你已经对 AuthenticationProvider 有了完全的控制。<br>
你可能会希望在 ProviderManager 中注册额外的 AuthenticationProvider ，你可以通过 authentication-provider元素的ref属性达到这个目的，属性的值是你希望添加的provider bean的名称。例如
```
<authentication-manager>
<authentication-provider ref="casAuthenticationProvider"/>
</authentication-manager>
<bean id="casAuthenticationProvider"
       class="org.springframework.security.cas.authentication.CasAuthenticationProvider">
...
</bean>
```
另外一个常见的需求是application context中的其他bean需要 AuthenticationManager的引用。你可以简单的为 AuthenticationManager 注册一个别名，然后application context中的其他任何地方来使用。
```
<authentication-manager alias="authenticationManager">
...
</authentication-manager>

<bean id="customizedFormLoginFilter"
        class="com.somecompany.security.web.CustomFormLoginFilter">
        <property name="authenticationManager" ref="authenticationManager"/>
...
</bean>
```
